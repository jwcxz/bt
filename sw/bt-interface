#!/usr/bin/env python2

import argparse, re, serial, time

DEF_PORT = '/dev/ttyUSB0';
DEF_BAUD = 115200;

DEF_NUM  = 60;
DEF_BASE = 120;

unicodechars = {
        '#': u'\u2588',
        '|': u'\u2502',
        '-': u'\u2500',
        'tl': u'\u250c',
        'tr': u'\u2510',
        'bl': u'\u2514',
        'br': u'\u2518',
        'ml': u'\u251c',
        'mr': u'\u2524',
        'mt': u'\u2534',
        'mb': u'\u252c',
        'mm': u'\u253c',
        }


colors = {
        'clear':  '\033[0m',
        'green':  '\033[92m',
        'yellow': '\033[93m',
        'red':    '\033[91m'
        }

class BTInterface:
    def __init__(self, port=DEF_PORT, baud=DEF_BAUD, num=DEF_NUM, base=DEF_BASE):

        self.cxn = serial.Serial(port, baud);
        self.num = num;
        self.base = base;

    def get(self):
        out = {};

        self.cxn.write('!');
        data = self.cxn.read(self.num);
        
        tempo = self.base;
        for c in data:
            out[tempo] = self.__convt(ord(c));
            tempo += 1;

        return out;

    def __convt(self, x):
        # get real phase
        if (x & 0x80):
            return -(((~x)&0x7F)+1)
        else:
            return x;

def line_color(val, maxval=128, colors=colors):
    if colors:
        cc = colors['clear'];

        # calculate bar color
        if abs(val) <= maxval/3.:
            c = colors['green'];
        elif abs(val) <= maxval*2/3.:
            c = colors['yellow'];
        else:
            c = colors['red'];
    else:
        cc = '';
        c = '';

    return (c,cc);

    

def histogram(val, maxval=128, half_width=20, chars=unicodechars, colors=colors):
    #center = width/2;
    bar_sz = int(round(half_width*abs(val)/float(maxval)));

    out = " "*half_width;
    out += chars['|'];
    out += chars['#']*bar_sz;
    out += " "*(half_width-bar_sz);

    if val < 0: out = out[::-1];

    return chars['|'] + out + chars['|'];



def clear_screen():
    print chr(27) + "[2J";


if __name__ == "__main__":
    p = argparse.ArgumentParser(description="bt analyzer interface");

    p.add_argument('-p', '--port', dest='port', type=str,
            action='store', default=DEF_PORT, help='serial port');

    p.add_argument('-b', '--baud', dest='baud', type=int,
            action='store', default=DEF_BAUD, help='baud rate');


    p.add_argument('-B', '--base-tempo', dest='basetempo', type=int,
            action='store', default=DEF_BASE, help='manually set base tempo');

    p.add_argument('-n', '--num-metronomes', dest='nummetronomes', type=int,
            action='store', default=DEF_NUM,
            help='manually set number of metronomes');

    p.add_argument('-a', '--auto', dest='auto', type=str,
            action='store', default=None,
            help='automatically get number of metronomes and base tempo from a BSV file');

    args = p.parse_args();

    decay = 0.1;


    num = args.nummetronomes;
    base = args.basetempo;

    if args.auto != None:
        re_met = re.compile('.*typedef\s+(?P<num>\d+)\s+NumMetronomes;.*');
        re_base = re.compile('.*Real\s+min_tempo\s+=\s+(?P<base>\d+)\s*;.*');
        f = open(args.auto, 'r');

        for line in f:
            if re_met.search(line):
                num = int(re_met.search(line).groupdict()['num']);
            elif re_base.search(line):
                base = int(re_base.search(line).groupdict()['base']);

        f.close();

    print "Grabbing data from %d metronomes with base tempo %d..." % (num, base);

    controller = BTInterface(args.port, args.baud, num, base);

    average = controller.get();

    ch = unicodechars;

    while True:
        data = controller.get();

        clear_screen();

        best = None;

        print ch['tl'] + ch['-']*5 + ch['mb'] + (ch['-']*6 + ch['mb'])*2 + \
                ch['-']*41 + ch['tr'];

        print "%c BPM %c  cur %c  avg %c " %(
                ch['|'], ch['|'],
                ch['|'], ch['|']),
        print " "*39 + ch['|'];

        print ch['ml'] + ch['-']*5 + ch['mm'] + (ch['-']*6 + ch['mm'])*2 + \
                ch['-']*20 + ch['mb'] + ch['-']*20 + ch['mr'];

        for tempo in sorted(data.keys()):
            average[tempo] = (1 - decay) * average[tempo] + (decay) * data[tempo];

            if best == None or abs(average[tempo]) < abs(average[best]):
                best = tempo;

            lc = line_color(average[tempo]);

            print "%s%c %3d %c %4d %c %4d %s%s" % (
                    lc[0],
                    ch['|'],
                    tempo,
                    ch['|'],
                    data[tempo],
                    ch['|'],
                    average[tempo],
                    histogram(average[tempo]),
                    lc[1]
                    );

        print ch['ml'] + ch['-']*5 + ch['mt'] + (ch['-']*6 + ch['mt'])*2 + \
                ch['-']*20 + ch['mt'] + ch['-']*20 + ch['mr'];

        print "%c Best Tempo Estimate: %3d BPM  [%4d / %4d]" % (
                ch['|'], best, data[best], average[best]),

        print " "*16 + ch['|'];

        print ch['bl'] + ch['-']*61 + ch['br'];

        time.sleep(.01);
